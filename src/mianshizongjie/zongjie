1.简单说说Java中的异常处理机制的简单原理和应用。

2.字节流和字符流的区别

3.垃圾回收的优点和原理。并考虑2种回收机制

4.说一说Servlet的生命周期?
Servlet的生命周期包括加载和实例化、初始化、调用服务、销毁。当Servlet被服务器实例化后，会调用init方法，当请求
到来时会调用其Service方法，服务器会自动派遣运行于请求相对应的doGet、doPost方法，当服务器决定销毁Servlet时，
会调用其destroy方法。

5.什么是cookie？Session和cookie有什么区别？
cookie和session都是会话跟踪机制
cookie是将用户信息保存到浏览器端,session是保存到服务器端
cookie不是很安全，一些重要的用户信息不要保存到cookie,应放到session中

6.JDBC访问数据库的基本步骤是什么？
1)加载驱动
2)根据DriverManager获取Connection
3)根据连接对象获取会话
4)进行CRUD操作
5)关闭资源

7.说说preparedStatement和Statement的区别
预编译会话比普通会话效率高，不会对相同的SQL语句重复编译
预编译会话可以预防SQL注入攻击，所谓的SQL注入攻击是指在客户端恶意提交导致服务器端仍然能够编写正确的SQL语句，
从而查询数据库的信息

8.说说事务的概念，在JDBC编程中处理事务的步骤
事务是指单个逻辑单元的一系列操作
事务包括四个特性，原子性、一致性、隔离性、持久性(ACID)
session.setAutoCommit(false)自动提交改为手动提交
session.commit()提交
出现异常session.rollback()回滚

9.数据库连接池的原理。为什么要使用连接池。
所谓的数据库连接池是指在程序初始化时建立一个“缓冲池”，在里面放入一定数量的连接，当需要时从池子中取出一个连接，用完后
放回池子，可以设置最大连接数防止与数据库的无限连接。作用是可以通过连接池的检测机制检测与数据库的连接数量、使用情况。

10.数据库不可重复读、脏读、幻读和各种隔离级别
脏读:事务A更新了数据，此时事务B读到了事务A刚更新的数据，因为更新的数据还没有持久化，更新这行数据的业务可能会回滚
脏读的隔离级别可以是串行化、可重复读，已提交读
幻读:一个事务多次执行一次查询到的结果不相同。例如事务A正在查询某个满足条件的数据查询，此时事务B插入一条满足条件的数据，此时事务A再查询就不对了
幻读的隔离级别是串行化

11.JDBC的DriverManager是用来做什么的？
DriverManager是个工厂类，把jdbc的Driver类加载进来

12.SQL查询出来的结果分页展示一般怎么做？
select * from student limit pageSize*(pageNumber-1) + "," + pageSize

13.对Struts的理解
1).Struts 是个MVC框架，实质上就是个Servlet,这个Servlet叫做ActionServlet,在web.xml中把符合某种特征的所有请求交给
这个Servlet处理，这个Servlet再参照另一个配置文件分发给不同的action去处理。
2).ActionServlet交给action处理之前，首先会把请求封装成一个java bean对象
3).如果开启了bean对象的validate方法，那么首先会先对其进行校验，如果校验成功，才会去调用action的execute方法，否则跳转到
错误页面，这个错误页面由input属性决定
4).action执行完成后的结果视图是个ActionForward对象，ActionForward通过struts-config.xml文件配置到与之关联的jsp页面

14.对Hibernate的理解
1).Hibernate是流行的ORM(关系对象映射型数据库)框架，封装了底层JDBC代码
2).使用步骤  配置Configuration对象,创建SessionFactory,创建Session对象，启动事务，执行CRUD操作，提交事务，关闭Session
3).使用Hibernate时，先配置hibernate.cfg.xml配置数据库信息和方言等，在xxx.hbm.xml中配置映射关系，加到hibernate.cfg.xml中

15.对Spring的理解
IOC:反转控制实现了松散耦合，只要给出它们的依赖，而不是通过查找或者创建找出依赖的对象
AOP:面向切面编程，在一些方法中需要加入系统模块的代码，例如日志配置，异常处理,事务。
使用的是代理技术实现的，客户端程序不再调用目标类，而是调用代理类，目标类和代理类对外具有相同的方法声明，一种方法是实现相同
的接口，另一种方法是作为目标的子类

16.介绍一下Hibernate的二级缓存
什么是缓存
二级缓存的作用是什么
如何配置二级缓存
1).所谓的缓存的就是从数据库中查询出来的对象放到内存中，类似于一个HashMap,下次查询的时候就不需要发送SQL语句，而只是从缓存中查询
2).一般session不能长时间开启，一般只作用于一次事务。而且session是线程不安全的，这就意味着它不能被其它线程共享。二级缓存就是个全局的，
多个线程和多个事务都可以共享。
3).在hibernate.cfg.xml中配置你需要的二级缓存商品，然后在其的配置文件中添加你所需要加入二级缓存的对象

17.Hibernate的一对多和多对一双向关联的区别？
一对多是从一的一端查询多的一端的对象，而多对一是从多的一端查询一的一端的对象

18.Hibernate是如何延迟加载? 
1).当Hibernate查询对象时，并没有将对象加载到内存中，而是真正需要用到这个对象的时候，这个对象才存在于内存中

19.ApplicationContext通常的实现是什么?

20.什么是Spring的依赖注入？有哪些方法进行依赖注入?

21.Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？

22.什么是死锁(Deadlock)？如何分析和避免死锁？
死锁是指两个以上的线程永远阻塞的情况
分析死锁，我们需要查询java应用程序的线程转储，我们需要找出那些状态为BLOCKED的线程和它们等待的资源，因为每一个资源
都有唯一确定的id,通过这个id我们可以找出哪些线程已经拥有了对象锁

23.什么是ThreadLocal?
ThreadLocal用于创建线程的本地变量，一般一个对象的所有线程会共享这个对象的全局变量，这个变量是线程不安全的，一种
方式是使用同步技术，另一种方式是是使用ThreadLocal
每个线程都会拥有它的Thread变量，可以使用set/get方法去获取默认值或者修改值，ThreadLocal实例通常是希望它们同线程状态
关联起来的是private static属性

24.什么是线程饿死，什么是活锁？
饿死:当所有的线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用
活锁:当所有的线程都调用object.wait方法，程序将发生活锁直到相应对象的线程调用notify方法

25.什么是线程池？ 为什么要使用它？
创建线程是需要花费时间和资源的，如果任务来了才建立，那么会响应时间会变长，而且一个进程能够创建的线程数是一定的
线程池就是在程序开始时建立多个线程来响应处理

26.编写一段泛型程序来实现LRU缓存?

集合底层原理解析:
ArrayList
HashMap
HashTable
CurrentHashMap


大搜车面试总结:
1.java线程间的通信方式，除了voltaile变量(管道机制怎么用)
1).同步，使用synchronized关键字
2).while轮询机制
3).wait,notify机制
4).管道机制
5).消息队列

2.Arrays.sort方法的排序原理是什么
JDK1.7以前是归并排序，在JDK1.7后优化成了TimeSort排序

3.object类有哪些方法
wait,notify,notifyAll,equals,hashcode,getClass,toString,finalize
getClass返回运行时类
clone:浅拷贝
toString:返回对象的字符串表示
notify:唤醒该对象监视器上等待的单个线程
notifyAll:唤醒该对象监视器上等待的所有线程
finalize:用于释放资源，因为无法确定该方法何时被调用，因此很少使用

4.http状态码包括哪些?
200:请求成功,一般用于GET和POST请求
201:已创建，成功请求并创建新的资源
202:已接受请求，但未处理完成
301:资源网页被永久转移到其它URL
403:已接受，但禁止服务
404:请求的资源不存在
500:服务器内部错误

5.http请求头包括哪些东西?
Accept-Charset:能够显示的字符集
Accept-Encoding:编码格式
Accept-Language:当前显示的语言
Cookie:当前页面设置的Cookie
Connection:当前的连接状态
User-Agent:浏览器用户代理字符串

6.AOP常用在哪些场景?
日志、事务、权限监控
两种方式:动态代理和静态织入

7.Spring传播方式
PROPAGATION_REQUIRED:如果没有当前事务，则新建一个事务。如果已经存在事务，则加入到事务中，最常见的选择。
PROPAGATION_REQUIRES_NEW:新建事务，如果存在当前事务，则将当前事务挂起
PROPAGATION_SUPPORTS:支持当前事务，如果没有事务，则以非事务的方式执行

8.SpringMVC如何返回Json数据?
在使用@RequestMapping注解后，返回值一般解析成路径跳转,加上@ResponseBody不会被解析成路径跳转，
而是写到Http响应正文(ResponseBody)中，一般在异步获取数据时使用，比如json,直接返回json数据 
@RequestBody注解将Http请求正文写到方法体中，使用适合的HttpMessageConverter将请求体写入某个对象

9.数据库4种隔离级别
1)丢失更新:两个事务同时更新一行数据，一个事务对数据的更新导致另一个事务对数据的更新覆盖
2)脏读:一个事务读取到了另一个事务未提交的数据
3)不可重复读:一个事务对同一行数据读取了两次，读到的结果不相同
4)幻读:一个事务对满足某种条件的记录进行多次查询，查询到的次数不相同，因为另一个事务插入或者删除了满足该条件的记录

未提交读:一个事务已经开始写数据，那么另外一个事务不允许同时进行写数据，但允许其它事务读此行数据，可以避免丢失更新，但不能避免脏读
也就是事务B读到了事务A未提交的数据
已提交读:读取数据的事务允许其它事务进行访问，但未提交的事务将禁止其它事务进行访问,可以避免脏读的出现,
但不能避免不可重复读，因为事务A读取了数据，事务B对数据进行了修改并提交，事务A再次读到的数据就不对了
可重复读:读取数据的事务将会禁止写操作(但允许读操作)，写数据的事务将禁止所有其它事务，可以避免不可重复读，但不能避免幻读
串行化:等级最高，可以避免所有

10.JVM的内存模型
1⃣程序计数器:当前线程所执行的字节码的行号指示器
2⃣虚拟机栈:线程私有，生命周期与线程相同。虚拟机栈描述的是方法执行的内存模型:每个方法被执行的时候都会同时创建一个栈帧(用于存储局部变量表，操作栈，方法出口等信息)
2.1)当前栈帧所关联的方法是当前方法
2.2)局部变量表:用于存放方法参数和方法内部的局部变量
2.3)操作数栈:通过压栈和弹栈来访问
2.4)动态链接:如果符号引用在类加载阶段或者第一次使用的时候转换成直接应用。这种转换是静态解析，如果在运行过程中进行转化，为动态链接
2.5)返回地址:
3⃣本地方法栈:与虚拟机栈的功能比较类似，虚拟机栈为虚拟机执行Java代码(字节码)服务，而本地方法栈是是为虚拟机的Native方法服务
4⃣堆:是Java虚拟机管理的最大一块内存，对所有线程共享，最主要的目的是为了存放对象实例。而且堆是垃圾回收器管理的最大内存，也称为GC堆
5⃣方法区:方法区在jvm实例的内部，类型信息存储在一个被称为方法区的内存逻辑中,类型信息是由类加载器在类加载时由类文件中提取出来的。静态变量
也存储在方法区中

11.Java类的加载机制
什么是类的加载:类的加载是指将类的.class文件中的二进制数据读到内存中，将其放在运行时数据区的方法区中，然后在内存的堆中创建一个java.lang.Class类
用来封装类在方法区中的数据结构。类的加载的最终产品是在堆中的Class对象

12.MyBatis一二级缓存
一级缓存:就是SqlSession,在操作数据库时需要构建SqlSession对象，对象内部有个数据结构可以存储缓存，不同SqlSession之间的缓存是互不影响且不能被
相互读取的
用户发起查询请求，SqlSession先去缓存中找，如果有，则读取，如果没有，则查询数据库，并加入到一级缓存中去。
但SqlSession执行commit时，会清空缓存，目的就是为了防止脏读
二级缓存:是mapper级别的缓存，多个SqlSession可以共享二级缓存,也就是二级缓存是跨SqlSession的

13.数据库常用的三大范式
1).第一范式:强调列的原子性，不能再分成其它几列
2).第二范式:没有包含在主键中的列必须完全依赖于主键，而不能依赖于主键的一部分
3).第三范式:非主键必须依赖于主键，不能存在传递关系

14.MySQL的优化


15.left join、right join、inner join

16.类加载机制，如果自己写的jar包应该放在哪里，自己定义了一个与jar包一样的类，会覆盖吗
1).装载:把java二进制文件导入jvm中，生成Class文件 
2).连接:a.检查Class文件的正确性  b.准备：给类的静态变量分配存储空间  c.解析：将符号引用转换成直接引用
3).初始化:对类的静态变量、静态方法和静态代码块初始化

17.Proxy和CGLIB
静态代理是对已经生成了的Java类进行封装
Proxy是动态代理，代理类与目标类实现相同的接口，CGLIB也是动态代理，实现目标类的子类

1).Proxy实现代理的目标类必须有实现接口
2).生成出来的代理类为接口实现类，和目标类不能进行转换，只能转为接口实现类进行调用

1).CGLIB实现方式是对代理的目标类进行继承
2).生成出了的代理类可以没方法，生成出来的类可以直接转换成目标类或目标类实现接口的实现类，因JAVA向上转换

JDK动态代理(Proxy)只能为实现了接口的类生成代理，代理类与目标类实现了相同的接口，目标类作为代理类的一个属性，在具体的接口实现中，
可以调用目标类的方法加上其它业务处理逻辑。而CGLIB是针对类实现代理，主要是对目标类生成子类，覆盖其方法。
Spring Aop主要用在权限控制、事务、日志管理。默认的策略是如果目标类实现了接口，那么使用JDK动态代理，没有实现接口就是CGLIB

18.数据库索引的作用
索引是种数据结构，最常见的是B树，还有哈希索引,哈希索引只能用来查询key-value这种值，因为是无序的,而B树是按照顺序存储的
索引的意义是通过缩小一张表中需要查询的记录／行的数目来加快搜索
索引中除了存储列的值，还存储着一个指向在行数据的索引

19.常见的MySQL优化
1).使用索引
2).少用SELECT *
3).使用NOT NULL
4).开启查询缓存
5).在where子句中避免使用or,一个字段有索引，一个字段没有索引，将导致进行全表扫描
select id from t where num=10 or Name = 'admin'
改为
select id from t where num = 10
union all
select id from t where Name = 'admin'
6).尽量使用变长字段varchar/nvarchar代替char/nchar,因为变长字段的存储空间小
7).考虑使用limit限制返回数据的量

20.ThreadLocal的使用方法
ThreadLocal不是一个线程的本地实例化，它的作用是为为每个使用该变量的线程提供一个变量值的副本,每个线程可以独立的改变本地副本，
不会与其它线程的副本发生冲突。ThreadLocal有个map,key就是线程，value就是变量值的副本

21.happens-before原则
如果两个操作满足happens-before原则，那么前一个操作对后一个操作是可见的
1).程序顺序原则:一个线程中的每个操作,happens-before于后面一个操作 
2).监视器锁原则:一个监视器对象的解锁操作，happens-before于监视器对象的加锁操作
3).voltaile原则:voltaile变量的写操作happens-before读操作之前
4).传递性:A happens-before B,B happens-before C,则A happens-before C
5).线程启动原则:一个线程的start happens-before于后序操作

22.SpringMVC运行流程
1).客户端发送请求到前端控制器DispatcherServlet
2).DispatcherServlet查询相应的HandlerMapping,并转发给控制器Controller
3).Controller处理完逻辑后，返回ModelAndView
4).DispatcherServlet查询一个或者多个ViewAndResolver,找到ModelAndView对应的视图
5).返回对应的视图给客户端

23.Spring配置事务方法

24.适配器模式、装饰者模式设计
适配器模式:将一个接口配置到另一个接口
装饰者模式:保持原有的接口，并增加其功能

25.Http协议的特点
1).支持客户端／服务器模式
2).简单快速:客户端只要发送请求方法和路径
3).灵活:传送内容可以是任何形式，用Content-Type标记
4).无连接:一次只处理一次请求
5).无状态:对事务处理没有记忆功能

26.自己写的jar包应该放在哪里


27.JDK容器的初使大小和扩容


28.ArrayList底层原理
Object src,int srcPos,Object dest,int destPos,int length


29.红黑树算法


30.java多线程的两种方式，继承Thread类和Runnable接口


31.java线程阻塞调用wait函数和sleep区别和联系，还有函数yield，notify等的作用。
wait是object方法，sleep是线程类Thread的类方法，wait会释放对象锁，而sleep只是线程休眠，并不会释放对象锁


32.comparable接口和comparator接口实现比较的区别和用法
1).Comparable的使用方式是:在欲比较类内部实现compareTo()方法，然后使用Collections.sort进行排序
   Comparator是在欲比较类外部实现的排序，Comparator是个专用的比较器，当比较函数不能满足要求的时候，自己设计比较器
2).一个类实现了Comparable接口表示这个类对象是可以相互比较的，类对象的集合可以使用Collections.sort使用
3).Comparator将算法和数据隔离

33.Arrays静态类如下实现排序的(Arrays.sort Collections.sort)
Arrays.sort 当阈值大于286的话，如果连续性好的话使用归并排序，连续性不好的话使用双轴快速排序
阈值大于47小于286的话，使用双轴快速排序，小于47的话使用插入排序
Collections.sort使用归并排序，System.setProperty("java.util.Arrays.useLegacyMergeSort", "true"); 
如果不为true的话，使用TimeSort排序

34.快排三种选基准方法和优化方法


35.设计一个分布式负载均衡缓冲系统，如何快速定位到是那个服务器（使用key分段、一致性hash）


36.说一说在浏览器中输入一个url后，直到浏览器显示页面的过程中发生了什么


37.ConcurrentHashMap如何扩容，内部结构？


38.知道java的异常吗？
Error类和Exception类都是继承Throwable,Error是程序无法处理的错误，Exception除了RuntimeException
及其子类都是不需要抛出的


39.小根堆和分而至之


40.还问了堆和栈中存的是什么？static修饰的变量存在哪里？
堆：存储的是new出来的对象，被所有线程共享
栈：基本类型的变量数据，和对象的引用(栈中只保存基础数据类型的对象（比如int i=1中1就是基础类型的对象和自定义对象的引用(不是对象)而真实对象都存放在堆区中)
常量池：存放基本类型常量和字符串常量
方法区：方法区包含所有的class和static变量


41.那ConcurrentHashMap内部是如何实现的？每个segment是个什么数据结构？（HashTable）



42.说说mybatis配置了xml过后是如何完成数据库操作的？


43.MongoDB的使用场景


44.Java静态代码块、构造函数、成员变量初始化顺序


45.带权有向图、无向图
