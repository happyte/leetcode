1.简单说说Java中的异常处理机制的简单原理和应用。

2.字节流和字符流的区别

3.垃圾回收的优点和原理。并考虑2种回收机制

4.说一说Servlet的生命周期?
Servlet的生命周期包括加载和实例化、初始化、调用服务、销毁。当Servlet被服务器实例化后，会调用init方法，当请求
到来时会调用其Service方法，服务器会自动派遣运行于请求相对应的doGet、doPost方法，当服务器决定销毁Servlet时，
会调用其destroy方法。

5.什么是cookie？Session和cookie有什么区别？
cookie和session都是会话跟踪机制
cookie是将用户信息保存到浏览器端,session是保存到服务器端
cookie不是很安全，一些重要的用户信息不要保存到cookie,应放到session中

6.JDBC访问数据库的基本步骤是什么？
1)加载驱动
2)根据DriverManager获取Connection
3)根据连接对象获取会话
4)进行CRUD操作
5)关闭资源

7.说说preparedStatement和Statement的区别
预编译会话比普通会话效率高，不会对相同的SQL语句重复编译
预编译会话可以预防SQL注入攻击，所谓的SQL注入攻击是指在客户端恶意提交导致服务器端仍然能够编写正确的SQL语句，
从而查询数据库的信息

8.说说事务的概念，在JDBC编程中处理事务的步骤
事务是指单个逻辑单元的一系列操作
事务包括四个特性，原子性、一致性、隔离性、持久性(ACID)
session.setAutoCommit(false)自动提交改为手动提交
session.commit()提交
出现异常session.rollback()回滚

9.数据库连接池的原理。为什么要使用连接池。
所谓的数据库连接池是指在程序初始化时建立一个“缓冲池”，在里面放入一定数量的连接，当需要时从池子中取出一个连接，用完后
放回池子，可以设置最大连接数防止与数据库的无限连接。作用是可以通过连接池的检测机制检测与数据库的连接数量、使用情况。

10.数据库不可重复读、脏读、幻读和各种隔离级别
脏读:事务A更新了数据，此时事务B读到了事务A刚更新的数据，因为更新的数据还没有持久化，更新这行数据的业务可能会回滚
脏读的隔离级别可以是串行化、可重复读，已提交读
幻读:一个事务多次执行一次查询到的结果不相同。例如事务A正在查询某个满足条件的数据查询，此时事务B插入一条满足条件的数据，此时事务A再查询就不对了
幻读的隔离级别是串行化

11.JDBC的DriverManager是用来做什么的？
DriverManager是个工厂类，把jdbc的Driver类加载进来

12.SQL查询出来的结果分页展示一般怎么做？
select * from student limit pageSize*(pageNumber-1) + "," + pageSize

13.对Struts的理解
1).Struts 是个MVC框架，实质上就是个Servlet,这个Servlet叫做ActionServlet,在web.xml中把符合某种特征的所有请求交给
这个Servlet处理，这个Servlet再参照另一个配置文件分发给不同的action去处理。
2).ActionServlet交给action处理之前，首先会把请求封装成一个java bean对象
3).如果开启了bean对象的validate方法，那么首先会先对其进行校验，如果校验成功，才会去调用action的execute方法，否则跳转到
错误页面，这个错误页面由input属性决定
4).action执行完成后的结果视图是个ActionForward对象，ActionForward通过struts-config.xml文件配置到与之关联的jsp页面

14.对Hibernate的理解
1).Hibernate是流行的ORM(关系对象映射型数据库)框架，封装了底层JDBC代码
2).使用步骤  配置Configuration对象,创建SessionFactory,创建Session对象，启动事务，执行CRUD操作，提交事务，关闭Session
3).使用Hibernate时，先配置hibernate.cfg.xml配置数据库信息和方言等，在xxx.hbm.xml中配置映射关系，加到hibernate.cfg.xml中

15.对Spring的理解
IOC:反转控制实现了松散耦合，只要给出它们的依赖，而不是通过查找或者创建找出依赖的对象
AOP:面向切面编程，在一些方法中需要加入系统模块的代码，例如日志配置，异常处理,事务。
使用的是代理技术实现的，客户端程序不再调用目标类，而是调用代理类，目标类和代理类对外具有相同的方法声明，一种方法是实现相同
的接口，另一种方法是作为目标的子类

16.介绍一下Hibernate的二级缓存
什么是缓存
二级缓存的作用是什么
如何配置二级缓存
1).所谓的缓存的就是从数据库中查询出来的对象放到内存中，类似于一个HashMap,下次查询的时候就不需要发送SQL语句，而只是从缓存中查询
2).一般session不能长时间开启，一般只作用于一次事务。而且session是线程不安全的，这就意味着它不能被其它线程共享。二级缓存就是个全局的，
多个线程和多个事务都可以共享。
3).在hibernate.cfg.xml中配置你需要的二级缓存商品，然后在其的配置文件中添加你所需要加入二级缓存的对象

17.Hibernate的一对多和多对一双向关联的区别？
一对多是从一的一端查询多的一端的对象，而多对一是从多的一端查询一的一端的对象

18.Hibernate是如何延迟加载? 
1).当Hibernate查询对象时，并没有将对象加载到内存中，而是真正需要用到这个对象的时候，这个对象才存在于内存中

19.ApplicationContext通常的实现是什么?

20.什么是Spring的依赖注入？有哪些方法进行依赖注入?

21.Hibernate中SessionFactory是线程安全的吗？Session是线程安全的吗（两个线程能够共享同一个Session吗）？

22.什么是死锁(Deadlock)？如何分析和避免死锁？
死锁是指两个以上的线程永远阻塞的情况
分析死锁，我们需要查询java应用程序的线程转储，我们需要找出那些状态为BLOCKED的线程和它们等待的资源，因为每一个资源
都有唯一确定的id,通过这个id我们可以找出哪些线程已经拥有了对象锁

23.什么是ThreadLocal?
ThreadLocal用于创建线程的本地变量，一般一个对象的所有线程会共享这个对象的全局变量，这个变量是线程不安全的，一种
方式是使用同步技术，另一种方式是是使用ThreadLocal
每个线程都会拥有它的Thread变量，可以使用set/get方法去获取默认值或者修改值，ThreadLocal实例通常是希望它们同线程状态
关联起来的是private static属性

24.什么是线程饿死，什么是活锁？
饿死:当所有的线程阻塞，或者由于需要的资源无效而不能处理，不存在非阻塞线程使资源可用
活锁:当所有的线程都调用object.wait方法，程序将发生活锁直到相应对象的线程调用notify方法

25.什么是线程池？ 为什么要使用它？
创建线程是需要花费时间和资源的，如果任务来了才建立，那么会响应时间会变长，而且一个进程能够创建的线程数是一定的
线程池就是在程序开始时建立多个线程来响应处理

26.编写一段泛型程序来实现LRU缓存?

集合底层原理解析:
ArrayList
HashMap
HashTable
CurrentHashMap


大搜车面试总结:
1.java线程间的通信方式，除了voltaile变量(管道机制怎么用)
1).同步，使用synchronized关键字
2).while轮询机制
3).wait,notify机制
4).管道机制
5).消息队列

2.Arrays.sort方法的排序原理是什么
JDK1.7以前是归并排序，在JDK1.7后优化成了TimeSort排序

3.object类有哪些方法
wait,notify,notifyAll,equals,hashcode,getClass,toString,finalize
getClass返回运行时类
clone:浅拷贝
toString:返回对象的字符串表示
notify:唤醒该对象监视器上等待的单个线程
notifyAll:唤醒该对象监视器上等待的所有线程
finalize:用于释放资源，因为无法确定该方法何时被调用，因此很少使用

4.http状态码包括哪些?
200:请求成功,一般用于GET和POST请求
201:已创建，成功请求并创建新的资源
202:已接受请求，但未处理完成
301:资源网页被永久转移到其它URL
403:已接受，但禁止服务
404:请求的资源不存在
500:服务器内部错误

5.http请求头包括哪些东西?
Accept-Charset:能够显示的字符集
Accept-Encoding:编码格式
Accept-Language:当前显示的语言
Cookie:当前页面设置的Cookie
Connection:当前的连接状态
User-Agent:浏览器用户代理字符串

6.AOP常用在哪些场景?
日志、事务、权限监控
两种方式:动态代理和静态织入

7.Spring传播方式
PROPAGATION_REQUIRED:如果没有当前事务，则新建一个事务。如果已经存在事务，则加入到事务中，最常见的选择。
PROPAGATION_REQUIRES_NEW:新建事务，如果存在当前事务，则将当前事务挂起
PROPAGATION_SUPPORTS:支持当前事务，如果没有事务，则以非事务的方式执行

8.SpringMVC如何返回Json数据?
在使用@RequestMapping注解后，返回值一般解析成路径跳转,加上@ResponseBody不会被解析成路径跳转，
而是写到Http响应正文(ResponseBody)中，一般在异步获取数据时使用，比如json,直接返回json数据 
@RequestBody注解将Http请求正文写到方法体中，使用适合的HttpMessageConverter将请求体写入某个对象

9.数据库4种隔离级别
1)丢失更新:两个事务同时更新一行数据，一个事务对数据的更新导致另一个事务对数据的更新覆盖
2)脏读:一个事务读取到了另一个事务未提交的数据
3)不可重复读:一个事务对同一行数据读取了两次，读到的结果不相同
4)幻读:一个事务对满足某种条件的记录进行多次查询，查询到的次数不相同，因为另一个事务插入或者删除了满足该条件的记录

未提交读:一个事务已经开始写数据，那么另外一个事务不允许同时进行写数据，但允许其它事务读此行数据，可以避免丢失更新，但不能避免脏读
也就是事务B读到了事务A未提交的数据
已提交读:读取数据的事务允许其它事务进行访问，但未提交的事务将禁止其它事务进行访问,可以避免脏读的出现,
但不能避免不可重复读，因为事务A读取了数据，事务B对数据进行了修改并提交，事务A再次读到的数据就不对了
可重复读:读取数据的事务将会禁止写操作(但允许读操作)，写数据的事务将禁止所有其它事务，可以避免不可重复读，但不能避免幻读
串行化:等级最高，可以避免所有

10.JVM的内存模型
1⃣程序计数器:当前线程所执行的字节码的行号指示器
2⃣虚拟机栈:线程私有，生命周期与线程相同。虚拟机栈描述的是方法执行的内存模型:每个方法被执行的时候都会同时创建一个栈帧(用于存储局部变量表，操作栈，方法出口等信息)
2.1)当前栈帧所关联的方法是当前方法
2.2)局部变量表:用于存放方法参数和方法内部的局部变量
2.3)操作数栈:通过压栈和弹栈来访问
2.4)动态链接:如果符号引用在类加载阶段或者第一次使用的时候转换成直接应用。这种转换是静态解析，如果在运行过程中进行转化，为动态链接
2.5)返回地址:
3⃣本地方法栈:与虚拟机栈的功能比较类似，虚拟机栈为虚拟机执行Java代码(字节码)服务，而本地方法栈是是为虚拟机的Native方法服务
4⃣堆:是Java虚拟机管理的最大一块内存，对所有线程共享，最主要的目的是为了存放对象实例。而且堆是垃圾回收器管理的最大内存，也称为GC堆
5⃣方法区:方法区在jvm实例的内部，类型信息存储在一个被称为方法区的内存逻辑中,类型信息是由类加载器在类加载时由类文件中提取出来的。静态变量
也存储在方法区中

11.Java类的加载机制
什么是类的加载:类的加载是指将类的.class文件中的二进制数据读到内存中，将其放在运行时数据区的方法区中，然后在内存的堆中创建一个java.lang.Class类
用来封装类在方法区中的数据结构。类的加载的最终产品是在堆中的Class对象

12.MyBatis一二级缓存
一级缓存:就是SqlSession,在操作数据库时需要构建SqlSession对象，对象内部有个数据结构可以存储缓存，不同SqlSession之间的缓存是互不影响且不能被
相互读取的
用户发起查询请求，SqlSession先去缓存中找，如果有，则读取，如果没有，则查询数据库，并加入到一级缓存中去。
但SqlSession执行commit时，会清空缓存，目的就是为了防止脏读
二级缓存:是mapper级别的缓存，多个SqlSession可以共享二级缓存,也就是二级缓存是跨SqlSession的

13.数据库常用的三大范式
1).第一范式:强调列的原子性，不能再分成其它几列
2).第二范式:没有包含在主键中的列必须完全依赖于主键，而不能依赖于主键的一部分
3).第三范式:非主键必须依赖于主键，不能存在传递关系

14.MySQL的优化


15.left join、right join、inner join


16.类加载机制，如果自己写的jar包应该放在哪里，自己定义了一个与jar包一样的类，会覆盖吗
1).装载:把java二进制文件导入jvm中，生成Class文件 
2).连接:a.检查Class文件的正确性  b.准备：给类的静态变量分配存储空间  c.解析：将符号引用转换成直接引用
3).初始化:对类的静态变量、静态方法和静态代码块初始化

17.Proxy和CGLIB
静态代理是对已经生成了的Java类进行封装
Proxy是动态代理，代理类与目标类实现相同的接口，CGLIB也是动态代理，实现目标类的子类

1).Proxy实现代理的目标类必须有实现接口
2).生成出来的代理类为接口实现类，和目标类不能进行转换，只能转为接口实现类进行调用

1).CGLIB实现方式是对代理的目标类进行继承
2).生成出了的代理类可以没方法，生成出来的类可以直接转换成目标类或目标类实现接口的实现类，因JAVA向上转换

JDK动态代理(Proxy)只能为实现了接口的类生成代理，代理类与目标类实现了相同的接口，目标类作为代理类的一个属性，在具体的接口实现中，
可以调用目标类的方法加上其它业务处理逻辑。而CGLIB是针对类实现代理，主要是对目标类生成子类，覆盖其方法。
Spring Aop主要用在权限控制、事务、日志管理。默认的策略是如果目标类实现了接口，那么使用JDK动态代理，没有实现接口就是CGLIB

18.数据库索引的作用
索引是种数据结构，最常见的是B树，还有哈希索引,哈希索引只能用来查询key-value这种值，因为是无序的,而B树是按照顺序存储的
索引的意义是通过缩小一张表中需要查询的记录／行的数目来加快搜索
索引中除了存储列的值，还存储着一个指向在行数据的索引

19.常见的MySQL优化
1).使用索引
2).少用SELECT *
3).使用NOT NULL
4).开启查询缓存
5).在where子句中避免使用or,一个字段有索引，一个字段没有索引，将导致进行全表扫描
select id from t where num=10 or Name = 'admin'
改为
select id from t where num = 10
union all
select id from t where Name = 'admin'
6).尽量使用变长字段varchar/nvarchar代替char/nchar,因为变长字段的存储空间小
7).考虑使用limit限制返回数据的量

20.ThreadLocal的使用方法
ThreadLocal不是一个线程的本地实例化，它的作用是为为每个使用该变量的线程提供一个变量值的副本,每个线程可以独立的改变本地副本，
不会与其它线程的副本发生冲突。ThreadLocal有个map,key就是线程，value就是变量值的副本

21.happens-before原则
如果两个操作满足happens-before原则，那么前一个操作对后一个操作是可见的
1).程序顺序原则:一个线程中的每个操作,happens-before于后面一个操作 
2).监视器锁原则:一个监视器对象的解锁操作，happens-before于监视器对象的加锁操作
3).voltaile原则:voltaile变量的写操作happens-before读操作之前
4).传递性:A happens-before B,B happens-before C,则A happens-before C
5).线程启动原则:一个线程的start happens-before于后序操作

22.SpringMVC运行流程
1).客户端发送请求到前端控制器DispatcherServlet
2).DispatcherServlet查询相应的HandlerMapping,并转发给控制器Controller
3).Controller处理完逻辑后，返回ModelAndView
4).DispatcherServlet查询一个或者多个ViewAndResolver,找到ModelAndView对应的视图
5).返回对应的视图给客户端

23.Spring配置事务方法

24.适配器模式、装饰者模式设计
适配器模式:将一个接口配置到另一个接口
装饰者模式:保持原有的接口，并增加其功能

25.Http协议的特点
1).支持客户端／服务器模式
2).简单快速:客户端只要发送请求方法和路径
3).灵活:传送内容可以是任何形式，用Content-Type标记
4).无连接:一次只处理一次请求
5).无状态:对事务处理没有记忆功能

26.自己写的jar包应该放在哪里


27.JDK容器的初使大小和扩容


28.ArrayList底层原理
Object src,int srcPos,Object dest,int destPos,int length


29.红黑树算法


30.java多线程的两种方式，继承Thread类和Runnable接口


31.java线程阻塞调用wait函数和sleep区别和联系，还有函数yield，notify等的作用。
wait是object方法，sleep是线程类Thread的类方法，wait会释放对象锁，而sleep只是线程休眠，并不会释放对象锁


32.comparable接口和comparator接口实现比较的区别和用法
1).Comparable的使用方式是:在欲比较类内部实现compareTo()方法，然后使用Collections.sort进行排序
   Comparator是在欲比较类外部实现的排序，Comparator是个专用的比较器，当比较函数不能满足要求的时候，自己设计比较器
2).一个类实现了Comparable接口表示这个类对象是可以相互比较的，类对象的集合可以使用Collections.sort使用
3).Comparator将算法和数据隔离

33.Arrays静态类如下实现排序的(Arrays.sort Collections.sort)
Arrays.sort 当阈值大于286的话，如果连续性好的话使用归并排序，连续性不好的话使用双轴快速排序
阈值大于47小于286的话，使用双轴快速排序，小于47的话使用插入排序
Collections.sort使用归并排序，System.setProperty("java.util.Arrays.useLegacyMergeSort", "true"); 
如果不为true的话，使用TimeSort排序

34.快排三种选基准方法和优化方法
方法(1)：固定位置
方法(2)：随机选取基准
方法(3)：三数取中（median-of-three）
优化1：当待排序序列的长度分割到一定大小后，使用插入排序
优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割
优化3：优化递归操作 快排函数在函数尾部有两次递归操作，我们可以对其使用尾递归优化
优化4：使用并行或多线程处理子序列


35.设计一个分布式负载均衡缓冲系统，如何快速定位到是那个服务器（使用key分段、一致性hash）


36.说一说在浏览器中输入一个url后，直到浏览器显示页面的过程中发生了什么


37.ConcurrentHashMap如何扩容，内部结构？


38.知道java的异常吗？
Error类和Exception类都是继承Throwable,Error是程序无法处理的错误，Exception除了RuntimeException
及其子类都是不需要抛出的


39.小根堆和分而至之


40.还问了堆和栈中存的是什么？static修饰的变量存在哪里？
堆：存储的是new出来的对象，被所有线程共享
栈：基本类型的变量数据，和对象的引用(栈中只保存基础数据类型的对象（比如int i=1中1就是基础类型的对象和自定义对象的引用(不是对象)而真实对象都存放在堆区中)
常量池：存放基本类型常量和字符串常量
方法区：方法区包含所有的class和static变量


41.那ConcurrentHashMap内部是如何实现的？每个segment是个什么数据结构？（HashTable）



42.说说mybatis配置了xml过后是如何完成数据库操作的？


43.MongoDB的使用场景
1).MongoDB更侧重高数据写入性能，而非事务安全，MongoDB很适合业务系统中有大量“低价值”数据的场景。但是应当避免在高事务安全性的系统中使用MongoDB
2).在MySQL中，当一个单达表到5-10GB时会出现明显的性能降级，此时需要通过数据的水平和垂直拆分、库的拆分完成扩展，
使用MySQL通常需要借助驱动层或代理层完成这类需求。而MongoDB内建了多种数据分片的特性，可以很好的适应大数据量的需求。
3).表结构不明确，且数据在不断变大


44.Java静态代码块、构造函数、成员变量初始化顺序
1).父类的静态成员变量和静态代码块加载
2).子类的静态成员变量和静态代码块加载
3).父类成员变量和方法块加载
4).父类的构造函数加载
5).子类成员变量和方法块加载
6).子类的构造函数加载

45.反射讲一讲，主要是概念,都在哪需要反射机制，反射的性能，如何优化
反射机制是指在运行过程中，对于任意一个类，能获取这个类的所有属性和方法。对于任意一个对象，能够调用它的任意一个方法。
这种动态获取信息及动态调用对象的方法称为反射。
反射提供的功能：
1.在运行过程中判断一个对象所属的类
2.构造任意一个类的对象
3.判断一个类所具有的属性和方法
4.调用任意对象的方法
5.动态代理


46.带权有向图、无向图
Dijk步骤:
a.初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，
则<u,v>正常有权值，若u不是v的出边邻接点，则<u,v>权值为∞。

b.从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。

c.以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，
则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。

d.重复步骤b和c直到所有顶点都包含在S中。

Floyd:
Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。
从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）

从任意节点i到任意节点j的最短路径不外乎2种可能，1是直接从i到j，2是从i经过若干个节点k到j。
所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查Dis(i,k) + Dis(k,j) < Dis(i,j)是否成立，如果成立，
证明从i到k再到j的路径比i直接到j的路径短，我们便设置Dis(i,j) = Dis(i,k) + Dis(k,j)，
这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。

2).算法描述：

a.从任意一条单边路径开始。所有两点之间的距离是边的权，如果两点之间没有边相连，则权为无穷大。 　　

b.对于每一对顶点 u 和 v，看看是否存在一个顶点 w 使得从 u 到 w 再到 v 比己知的路径更短。如果是更新它。

3).Floyd算法过程矩阵的计算----十字交叉法
方法：两条线，从左上角开始计算一直到右下角 如下所示
给出矩阵，其中矩阵A是邻接矩阵，而矩阵Path记录u,v两点之间最短路径所必须经过的点

SPFA:
SPFA(Shortest Path Faster Algorithm) [图的存储方式为邻接表]
是Bellman-Ford算法的一种队列实现，减少了不必要的冗余计算。
算法大致流程是用一个队列来进行维护。 初始时将源加入队列。 每次从队列中取出一个元素，
并对所有与他相邻的点进行松弛，若某个相邻的点松弛成功，则将其入队。 直到队列为空时算法结束。
SPFA 在形式上和BFS非常类似，不同的是BFS中一个点出了队列就不可能重新进入队列，但是SPFA中
一个点可能在出队列之后再次被放入队列，也就是一个点改进过其它的点之后，过了一段时间可能本
身被改进，于是再次用来改进其它的点，这样反复迭代下去。
判断有无负环：如果某个点进入队列的次数超过V次则存在负环（SPFA无法处理带负环的图）。


47.Java AQS


48.TCP 网络SANT WORKS协议


49.10个线程与主线程的问题


50.GC垃圾回收算法(a引用b,b引用a)
1.引用计数器法:给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；
当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不再被使用的，垃圾收集器将回收该对象使用的内存。
2.根搜索算法:通过一系列的名为“GC Root”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链，
当一个对象到GC Root没有任何引用链相连时，则该对象不可达，该对象是不可使用的，垃圾收集器将回收其所占的内存。


51.分布式hash算法，如何解决哈希冲突
1.开放式地址法
1.1 线性探测法：线性再散列法，如果发生冲突，会从该槽位置向后遍历hash表，直到找到表中下一个空槽，并把该元素放入槽中
1.2 线性补偿探测法：将线性探测的步长从 1 改为 Q ，即将上述算法中的 hash ＝ (hash ＋ 1) % m 改为：hash ＝ (hash ＋ Q) % m = hash % m + Q % m
2.拉链法:hashmap
3.发生冲突，可以使用第二个、第三个哈希函数再计算地址，直到无冲突
4.建立一个公共溢出区


52.HashTable和HashMap的区别，除了同步问题


53.并发包的计算器


54.ApplicationContext和BeanFactory
BeanFacotry是spring中比较原始的Factory。如XMLBeanFactory就是一种典型的BeanFactory。
原始的BeanFactory无法支持spring的许多插件，如AOP功能、Web应用等。ApplicationContext接口,它由BeanFactory接口派生而来，
因而提供BeanFactory所有的功能。ApplicationContext以一种更向面向框架的方式工作以及对上下文进行分层和实现继承
ApplicationContext包还提供了以下的功能：
  • MessageSource, 提供国际化的消息访问  
  • 资源访问，如URL和文件  
  • 事件传播  
  • 载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层  


55.CPU调度进程算法
1).先来先服务		 算法原理:进程按照它们请求CPU的顺序使用CPU,谁排第一个，谁先被执行，在执行过程中，不会去中断它
2).最短作业优先    算法原理:对预计时间短的进程优先处理
3).时间片轮转算法   算法原理:让就绪进程以FCFS的方式按时间片轮流,将所有就绪进程按照FCFS方式排成一个队列，每次调度将
CPU分配给队首进程，让其执行一个时间片，长度从几ms到几百ms。当一个时间片结束后，发生时钟中断，调度程序据此结束当前进程，
将其送到就绪队列的末尾


56.voltaile和static一起使用
